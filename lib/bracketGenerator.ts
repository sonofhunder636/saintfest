// lib/bracketGenerator.ts
import { 
  Saint, 
  Bracket, 
  BracketCategory, 
  BracketSaint, 
  BracketRound, 
  BracketMatch, 
  BracketGenerationConfig,
  BracketColorPalette
} from '@/types';
import { db } from '@/lib/firebase';
import { collection, query, where, getDocs, orderBy, limit } from 'firebase/firestore';

// Default color palette that complements mint green
const DEFAULT_COLOR_PALETTE: BracketColorPalette = {
  primary: '#8FBC8F', // Mint green
  category1: '#E6E6FA', // Lavender
  category2: '#FFE4B5', // Moccasin
  category3: '#F0E68C', // Khaki
  category4: '#DDA0DD', // Plum
  accent: '#4682B4', // Steel Blue
  text: '#2F4F4F', // Dark Slate Gray
  background: '#FFFFFF'
};

// Category mappings from database fields to display names
const CATEGORY_MAPPINGS: Record<keyof Saint, string> = {
  martyrs: 'Martyrs',
  confessors: 'Confessors', 
  doctorsofthechurch: 'Doctors of the Church',
  mystic: 'Mystics',
  missionary: 'Missionaries',
  religious: 'Religious',
  royalty: 'Royalty',
  bishop: 'Bishops',
  pope: 'Popes',
  apostle: 'Apostles',
  abbotabbess: 'Abbots & Abbesses',
  hermit: 'Hermits'
} as const;

export class BracketGenerator {
  private config: BracketGenerationConfig;
  private allSaints: Saint[] = [];

  constructor(config: BracketGenerationConfig) {
    this.config = config;
  }

  async generateBracket(): Promise<Bracket> {
    // Load all saints from database
    await this.loadSaints();

    // Select and validate categories
    const categories = await this.generateCategories();
    
    // Generate bracket rounds and matches
    const rounds = this.generateRounds(categories);

    // Create the complete bracket
    const bracket: Bracket = {
      id: `bracket-${this.config.year}`,
      year: this.config.year,
      title: `Saintfest ${this.config.year}`,
      categories,
      rounds,
      status: 'draft',
      createdAt: new Date(),
      autoGeneratedOn: new Date()
    };

    return bracket;
  }

  private async loadSaints(): Promise<void> {
    const saintsRef = collection(db, 'saints');
    const snapshot = await getDocs(saintsRef);
    
    this.allSaints = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    } as Saint));
  }

  private async generateCategories(): Promise<BracketCategory[]> {
    const categories: BracketCategory[] = [];
    const positions: Array<'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'> = 
      ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
    const colors = [
      this.config.colorPalette.category1,
      this.config.colorPalette.category2,
      this.config.colorPalette.category3,
      this.config.colorPalette.category4
    ];

    for (let i = 0; i < this.config.selectedCategories.length; i++) {
      const categoryKey = this.config.selectedCategories[i];
      const saintsForCategory = await this.selectSaintsForCategory(categoryKey);
      
      const category: BracketCategory = {
        id: `${this.config.year}-${categoryKey}`,
        name: CATEGORY_MAPPINGS[categoryKey] || String(categoryKey),
        color: colors[i],
        position: positions[i],
        categoryKey,
        saints: saintsForCategory
      };
      
      categories.push(category);
    }

    return categories;
  }

  private async selectSaintsForCategory(categoryKey: keyof Saint): Promise<BracketSaint[]> {
    // Filter saints by category and exclude recently used ones
    const eligibleSaints = this.allSaints.filter(saint => {
      // Must have the category flag
      if (!saint[categoryKey]) return false;
      
      // Exclude recently used saints if configured
      if (this.config.excludeRecentlyUsed && saint.lastUsedYear) {
        const yearsSinceLastUsed = this.config.year - saint.lastUsedYear;
        if (yearsSinceLastUsed < 2) return false; // Don't reuse for 2 years
      }
      
      return true;
    });

    // Randomly select 8 saints
    const shuffled = [...eligibleSaints].sort(() => Math.random() - 0.5);
    const selected = shuffled.slice(0, 8);

    // Convert to BracketSaint format with seeding
    return selected.map((saint, index) => ({
      saintId: saint.id,
      name: saint.name,
      seed: index + 1,
      imageUrl: saint.imageUrl,
      eliminated: false
    }));
  }

  private generateRounds(categories: BracketCategory[]): BracketRound[] {
    const rounds: BracketRound[] = [
      { roundNumber: 1, roundName: 'Round 1', matches: [] },
      { roundNumber: 2, roundName: 'Round 2', matches: [] },
      { roundNumber: 3, roundName: 'Elite Eight', matches: [] },
      { roundNumber: 4, roundName: 'Final Four', matches: [] },
      { roundNumber: 5, roundName: 'Championship', matches: [] }
    ];

    // Generate Round 1 matches (32 saints → 16)
    let matchId = 1;
    categories.forEach((category, categoryIndex) => {
      for (let i = 0; i < category.saints.length; i += 2) {
        const saint1 = category.saints[i];
        const saint2 = category.saints[i + 1];
        
        const match: BracketMatch = {
          matchId: `R1-M${matchId}`,
          saint1Id: saint1.saintId,
          saint2Id: saint2.saintId,
          saint1Name: saint1.name,
          saint2Name: saint2.name,
          votesForSaint1: 0,
          votesForSaint2: 0,
          position: this.calculateMatchPosition(1, matchId, categoryIndex),
          categoryPosition: category.position
        };
        
        rounds[0].matches.push(match);
        matchId++;
      }
    });

    // Generate placeholder matches for subsequent rounds
    // These will be populated as the tournament progresses
    this.generatePlaceholderMatches(rounds);

    return rounds;
  }

  private calculateMatchPosition(round: number, matchNumber: number, categoryIndex?: number): { x: number; y: number } {
    // Basic positioning logic - you can enhance this for exact visual layout
    const baseX = round * 200; // Horizontal spacing between rounds
    const baseY = matchNumber * 100; // Vertical spacing between matches
    
    return {
      x: baseX,
      y: baseY + (categoryIndex ? categoryIndex * 800 : 0) // Category spacing
    };
  }

  private generatePlaceholderMatches(rounds: BracketRound[]): void {
    // Round 2: 16 → 8 (8 matches)
    for (let i = 1; i <= 8; i++) {
      rounds[1].matches.push({
        matchId: `R2-M${i}`,
        saint1Id: 'TBD',
        saint2Id: 'TBD',
        saint1Name: 'TBD',
        saint2Name: 'TBD',
        votesForSaint1: 0,
        votesForSaint2: 0,
        position: this.calculateMatchPosition(2, i)
      });
    }

    // Round 3: 8 → 4 (4 matches)
    for (let i = 1; i <= 4; i++) {
      rounds[2].matches.push({
        matchId: `R3-M${i}`,
        saint1Id: 'TBD',
        saint2Id: 'TBD',
        saint1Name: 'TBD',
        saint2Name: 'TBD',
        votesForSaint1: 0,
        votesForSaint2: 0,
        position: this.calculateMatchPosition(3, i)
      });
    }

    // Round 4: 4 → 2 (2 matches)
    for (let i = 1; i <= 2; i++) {
      rounds[3].matches.push({
        matchId: `R4-M${i}`,
        saint1Id: 'TBD',
        saint2Id: 'TBD',
        saint1Name: 'TBD',
        saint2Name: 'TBD',
        votesForSaint1: 0,
        votesForSaint2: 0,
        position: this.calculateMatchPosition(4, i)
      });
    }

    // Round 5: 2 → 1 (1 match)
    rounds[4].matches.push({
      matchId: 'CHAMPIONSHIP',
      saint1Id: 'TBD',
      saint2Id: 'TBD',
      saint1Name: 'TBD',
      saint2Name: 'TBD',
      votesForSaint1: 0,
      votesForSaint2: 0,
      position: this.calculateMatchPosition(5, 1)
    });
  }

  // Utility method to get available categories
  static getAvailableCategories(): Array<{ key: keyof Saint; name: string }> {
    return Object.entries(CATEGORY_MAPPINGS).map(([key, name]) => ({
      key: key as keyof Saint,
      name
    }));
  }

  // Utility method to update saint usage
  static async markSaintsAsUsed(saintIds: string[], year: number): Promise<void> {
    // This would update the lastUsedYear field for the selected saints
    // Implementation depends on your Firebase update strategy
  }
}

// Helper function to create a default bracket configuration
export function createDefaultBracketConfig(year: number): BracketGenerationConfig {
  // Default to popular categories - you can randomize this
  const defaultCategories: Array<keyof Saint> = ['martyrs', 'confessors', 'doctorsofthechurch', 'mystic'];
  
  return {
    year,
    selectedCategories: defaultCategories,
    excludeRecentlyUsed: true,
    colorPalette: DEFAULT_COLOR_PALETTE
  };
}

// Main generation function
export async function generateNewBracket(year: number): Promise<Bracket> {
  const config = createDefaultBracketConfig(year);
  const generator = new BracketGenerator(config);
  return await generator.generateBracket();
}