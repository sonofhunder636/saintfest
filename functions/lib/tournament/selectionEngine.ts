// lib/tournament/selectionEngine.ts
import { 
  Saint, 
  Tournament, 
  TournamentCategory, 
  TournamentSaint, 
  TournamentConfig,
  TournamentColors 
} from '@/types';
import { assertFirestore } from '@/lib/firebase';
import { collection, getDocs, query, where, orderBy } from 'firebase/firestore';

// Default color palette that complements mint green theme
const DEFAULT_COLORS: TournamentColors = {
  primary: '#8FBC8F', // Mint green (site theme)
  secondary: '#4682B4', // Steel blue
  categories: [
    '#E6E6FA', // Lavender
    '#FFE4B5', // Moccasin
    '#F0E68C', // Khaki
    '#DDA0DD', // Plum
  ],
  text: '#2F4F4F', // Dark slate gray
  background: '#FFFFFF',
  lines: '#8FBC8F', // Mint green for bracket lines
  hover: '#7FB07F', // Darker mint for hover states
};

// Category display names mapping
const CATEGORY_NAMES: Record<string, string> = {
  martyrs: 'Martyrs',
  confessors: 'Confessors',
  doctorsofthechurch: 'Doctors of the Church',
  virgins: 'Virgins',
  mystic: 'Mystics',
  missionary: 'Missionaries',
  religious: 'Religious',
  royalty: 'Royalty',
  bishop: 'Bishops',
  pope: 'Popes',
  apostle: 'Apostles',
  abbotabbess: 'Abbots & Abbesses',
  hermit: 'Hermits',
  holywoman: 'Holy Women',
  priest: 'Priests',
  deacon: 'Deacons',
  churchfather: 'Church Fathers',
  lay: 'Laypeople'
};

// Get all valid saint categories from the Saint interface
const VALID_CATEGORIES: Array<keyof Saint> = [
  'martyrs', 'confessors', 'doctorsofthechurch', 'virgins', 'mystic',
  'missionary', 'religious', 'royalty', 'bishop', 'pope', 'apostle',
  'abbotabbess', 'hermit', 'holywoman', 'priest', 'deacon', 'churchfather', 'lay'
];

export class TournamentSelectionEngine {
  private saints: Saint[] = [];
  private config: TournamentConfig;

  constructor(config: TournamentConfig) {
    this.config = config;
  }

  /**
   * Generate a complete tournament with intelligent saint selection
   */
  async generateTournament(): Promise<Tournament> {
    const startTime = Date.now();
    
    // Load all saints from database
    await this.loadSaints();
    
    // Select 4 categories (random or forced)
    const selectedCategories = this.selectCategories();
    
    // Create tournament categories with 8 saints each
    const categories = await this.createTournamentCategories(selectedCategories);
    
    // Generate the tournament structure
    const tournament: Tournament = {
      id: `tournament-${this.config.year}`,
      year: this.config.year,
      title: `Saintfest ${this.config.year}`,
      categories,
      rounds: this.generateRounds(categories),
      status: 'draft',
      createdAt: new Date(),
      autoGeneratedOn: new Date(),
      colorPalette: this.config.colorPalette || DEFAULT_COLORS,
      metadata: {
        totalSaints: 32,
        categoriesUsed: selectedCategories,
        selectionMethod: this.config.forcedCategories ? 'manual' : 'random',
        generationTime: Date.now() - startTime,
        textMeasurements: {
          longestName: this.findLongestName(categories),
          maxTextWidth: 0, // Will be calculated by layout engine
          maxTextHeight: 0, // Will be calculated by layout engine
        },
        bracketDimensions: {
          totalWidth: 0, // Will be calculated by layout engine
          totalHeight: 0, // Will be calculated by layout engine
          scaleFactor: 1,
        }
      }
    };

    return tournament;
  }

  /**
   * Load all saints from Firestore
   */
  async loadSaints(): Promise<void> {
    try {
      const db = assertFirestore();
      const saintsRef = collection(db, 'saints');
      const snapshot = await getDocs(saintsRef);
      
      this.saints = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      } as Saint));
      
      console.log(`Loaded ${this.saints.length} saints from database`);
    } catch (error) {
      console.error('Error loading saints:', error);
      throw new Error('Failed to load saints from database');
    }
  }

  /**
   * Select 4 categories for the tournament
   */
  private selectCategories(): string[] {
    if (this.config.forcedCategories) {
      if (this.config.forcedCategories.length !== 4) {
        throw new Error('Must provide exactly 4 categories');
      }
      return this.config.forcedCategories;
    }

    // Find categories with enough saints
    const validCategories = VALID_CATEGORIES.filter(category => {
      const saintsInCategory = this.getSaintsInCategory(category);
      return saintsInCategory.length >= 8; // Need at least 8 saints per category
    });

    if (validCategories.length < 4) {
      throw new Error('Not enough categories with sufficient saints');
    }

    // Randomly select 4 categories
    const shuffled = [...validCategories].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, 4);
  }

  /**
   * Get all saints in a specific category
   */
  getSaintsInCategory(category: keyof Saint): Saint[] {
    return this.saints.filter(saint => {
      // Must have the category flag
      if (!saint[category]) return false;
      
      // Exclude recently used saints if configured
      if (this.config.excludeRecentlyUsed && saint.lastUsedYear) {
        const yearsSinceLastUsed = this.config.year - saint.lastUsedYear;
        if (yearsSinceLastUsed < this.config.yearsToExclude) {
          return false;
        }
      }
      
      return true;
    });
  }

  /**
   * Create tournament categories with selected saints
   */
  private async createTournamentCategories(selectedCategories: string[]): Promise<TournamentCategory[]> {
    const categories: TournamentCategory[] = [];
    const positions: Array<'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'> = 
      ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
    const colors = this.config.colorPalette?.categories || DEFAULT_COLORS.categories;

    for (let i = 0; i < selectedCategories.length; i++) {
      const categoryKey = selectedCategories[i] as keyof Saint;
      const saints = await this.selectSaintsForCategory(categoryKey);
      
      const category: TournamentCategory = {
        id: `${this.config.year}-${categoryKey}`,
        name: CATEGORY_NAMES[categoryKey] || String(categoryKey),
        categoryKey,
        color: colors[i] || colors[0],
        position: positions[i],
        saints
      };
      
      categories.push(category);
    }

    return categories;
  }

  /**
   * Select 8 saints for a category using weighted random selection
   */
  private async selectSaintsForCategory(category: keyof Saint): Promise<TournamentSaint[]> {
    const eligibleSaints = this.getSaintsInCategory(category);
    
    if (eligibleSaints.length < 8) {
      throw new Error(`Category ${String(category)} has only ${eligibleSaints.length} eligible saints, need at least 8`);
    }

    let selectedSaints: Saint[] = [];

    if (this.config.selectionWeighting === 'popularity' && eligibleSaints.some(s => s.popularityScore)) {
      // Weighted selection based on popularity scores
      selectedSaints = this.selectWeightedRandom(eligibleSaints, 8);
    } else if (this.config.selectionWeighting === 'balanced') {
      // Balanced selection - mix of popular and less popular
      selectedSaints = this.selectBalanced(eligibleSaints, 8);
    } else {
      // Pure random selection
      selectedSaints = this.selectPureRandom(eligibleSaints, 8);
    }

    // Convert to TournamentSaint format
    return selectedSaints.map((saint, index) => ({
      id: saint.id,
      name: saint.name,
      displayName: saint.displayName || this.optimizeNameForBracket(saint.name),
      seed: index + 1,
      imageUrl: saint.imageUrl,
      feastDay: saint.feastDay,
      popularityScore: saint.popularityScore || 50, // Default to middle score
      eliminated: false
    }));
  }

  /**
   * Weighted random selection based on popularity scores
   */
  selectWeightedRandom(saints: Saint[], count: number): Saint[] {
    const selected: Saint[] = [];
    const remaining = [...saints];

    for (let i = 0; i < count && remaining.length > 0; i++) {
      // Calculate total weight of remaining saints
      const totalWeight = remaining.reduce((sum, saint) => sum + (saint.popularityScore || 50), 0);
      
      // Random selection based on weights
      let randomWeight = Math.random() * totalWeight;
      let selectedIndex = 0;
      
      for (let j = 0; j < remaining.length; j++) {
        randomWeight -= (remaining[j].popularityScore || 50);
        if (randomWeight <= 0) {
          selectedIndex = j;
          break;
        }
      }
      
      selected.push(remaining[selectedIndex]);
      remaining.splice(selectedIndex, 1);
    }

    return selected;
  }

  /**
   * Balanced selection - mix of popular and less popular saints
   */
  selectBalanced(saints: Saint[], count: number): Saint[] {
    // Sort by popularity score
    const sorted = [...saints].sort((a, b) => (b.popularityScore || 50) - (a.popularityScore || 50));
    
    const selected: Saint[] = [];
    const topTier = sorted.slice(0, Math.floor(sorted.length / 3));
    const middleTier = sorted.slice(Math.floor(sorted.length / 3), Math.floor(sorted.length * 2 / 3));
    const bottomTier = sorted.slice(Math.floor(sorted.length * 2 / 3));
    
    // Select from each tier proportionally
    const topCount = Math.ceil(count / 2);
    const middleCount = Math.floor(count / 3);
    const bottomCount = count - topCount - middleCount;
    
    selected.push(...this.selectPureRandom(topTier, Math.min(topCount, topTier.length)));
    selected.push(...this.selectPureRandom(middleTier, Math.min(middleCount, middleTier.length)));
    selected.push(...this.selectPureRandom(bottomTier, Math.min(bottomCount, bottomTier.length)));
    
    // Fill remaining slots if needed
    while (selected.length < count && saints.length > selected.length) {
      const remaining = saints.filter(s => !selected.includes(s));
      if (remaining.length > 0) {
        selected.push(...this.selectPureRandom(remaining, Math.min(count - selected.length, remaining.length)));
      }
    }
    
    return selected.slice(0, count);
  }

  /**
   * Pure random selection
   */
  selectPureRandom(saints: Saint[], count: number): Saint[] {
    const shuffled = [...saints].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, count);
  }

  /**
   * Optimize saint name for bracket display
   */
  optimizeNameForBracket(name: string): string {
    // Remove common prefixes
    let optimized = name.replace(/^(Saint|St\.|St)\s+/i, '');
    
    // Handle very long names
    if (optimized.length > 20) {
      // Try to use first name and last name only
      const parts = optimized.split(' ');
      if (parts.length > 2) {
        optimized = `${parts[0]} ${parts[parts.length - 1]}`;
      }
    }
    
    return optimized;
  }

  /**
   * Find the longest name across all categories
   */
  private findLongestName(categories: TournamentCategory[]): string {
    let longest = '';
    
    categories.forEach(category => {
      category.saints.forEach(saint => {
        if (saint.displayName.length > longest.length) {
          longest = saint.displayName;
        }
      });
    });
    
    return longest;
  }

  /**
   * Generate the tournament round structure
   */
  private generateRounds(categories: TournamentCategory[]): any[] {
    // This will be implemented by the layout engine
    // For now, return empty structure to be filled later
    return [
      { roundNumber: 1, roundName: 'Round of 32', matches: [] },
      { roundNumber: 2, roundName: 'Round of 16', matches: [] },
      { roundNumber: 3, roundName: 'Elite Eight', matches: [] },
      { roundNumber: 4, roundName: 'Final Four', matches: [] },
      { roundNumber: 5, roundName: 'Championship', matches: [] }
    ];
  }

  /**
   * Static method to get available categories for admin selection
   */
  static getAvailableCategories(): Array<{ key: keyof Saint; name: string; description?: string }> {
    return VALID_CATEGORIES.map(key => ({
      key,
      name: CATEGORY_NAMES[key] || String(key),
      description: `Saints in the ${CATEGORY_NAMES[key] || String(key)} category`
    }));
  }

  /**
   * Static method to create default tournament config
   */
  static createDefaultConfig(year: number): TournamentConfig {
    return {
      year,
      excludeRecentlyUsed: true,
      yearsToExclude: 2,
      colorPalette: DEFAULT_COLORS,
      selectionWeighting: 'balanced',
      textSizeCalculation: 'dynamic',
      exportFormats: ['pdf', 'png']
    };
  }
}

/**
 * Main function to generate a new tournament
 */
export async function generateTournament(config?: Partial<TournamentConfig>): Promise<Tournament> {
  const currentYear = new Date().getFullYear();
  const fullConfig = {
    ...TournamentSelectionEngine.createDefaultConfig(currentYear),
    ...config
  };
  
  const engine = new TournamentSelectionEngine(fullConfig);
  return await engine.generateTournament();
}

/**
 * Function to regenerate just one category
 */
export async function regenerateCategory(
  tournament: Tournament, 
  categoryId: string, 
  newCategoryKey?: keyof Saint
): Promise<TournamentCategory> {
  const config = TournamentSelectionEngine.createDefaultConfig(tournament.year);
  const engine = new TournamentSelectionEngine(config);
  
  await engine.loadSaints();
  
  const categoryKey = newCategoryKey || tournament.categories.find(c => c.id === categoryId)?.categoryKey;
  if (!categoryKey) {
    throw new Error('Category not found');
  }
  
  const eligibleSaints = engine.getSaintsInCategory(categoryKey);
  let selectedSaints: Saint[] = [];

  if (config.selectionWeighting === 'popularity' && eligibleSaints.some(s => s.popularityScore)) {
    selectedSaints = engine.selectWeightedRandom(eligibleSaints, 8);
  } else if (config.selectionWeighting === 'balanced') {
    selectedSaints = engine.selectBalanced(eligibleSaints, 8);
  } else {
    selectedSaints = engine.selectPureRandom(eligibleSaints, 8);
  }

  const saints = selectedSaints.map((saint, index) => ({
    id: saint.id,
    name: saint.name,
    displayName: saint.displayName || engine.optimizeNameForBracket(saint.name),
    seed: index + 1,
    imageUrl: saint.imageUrl,
    feastDay: saint.feastDay,
    popularityScore: saint.popularityScore || 50,
    eliminated: false
  }));
  const originalCategory = tournament.categories.find(c => c.id === categoryId);
  
  return {
    id: categoryId,
    name: CATEGORY_NAMES[categoryKey] || String(categoryKey),
    categoryKey,
    color: originalCategory?.color || DEFAULT_COLORS.categories[0],
    position: originalCategory?.position || 'top-left',
    saints
  };
}